create extension vector with schema extensions;

create type jobs_status as ENUM (
  'pending',
  'running',
  'completed',
  'failed'
);

create type sender as ENUM (
  'user',
  'assistant'
);

create type message_type as ENUM (
  'ai',
  'db',
  'user'
);

create table chatbots (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  description text,
  url text not null,
  site_name text not null,
  organization_id bigint not null references public.organizations on delete cascade,
  created_at timestamptz default now() not null,
  settings jsonb default '{
    "title": "AI Assistant",
    "branding": {
      "textColor": "#fff",
      "primaryColor": "#0a0a0a",
      "accentColor": "#0a0a0a"
    },
    "position": "bottom-right"
  }' not null
);

create table documents (
  id uuid primary key default gen_random_uuid(),
  embedding vector (1536),
  content text not null,
  metadata jsonb default '{}' not null,
  created_at timestamptz default now() not null
);

create table conversations (
  id uuid primary key default gen_random_uuid(),
  reference_id text not null,
  chatbot_id uuid not null references public.chatbots on delete cascade,
  created_at timestamptz default now() not null,
  user_email text
);

create table messages (
  id bigint generated by default as identity primary key,
  conversation_id uuid not null references public.conversations on delete cascade,
  chatbot_id uuid not null references public.chatbots on delete cascade,
  text text not null,
  sender sender not null,
  type message_type not null,
  created_at timestamptz default now() not null
);

create table jobs (
  id bigint generated always as identity primary key,
  chatbot_id uuid not null references public.chatbots on delete cascade,
  organization_id bigint not null references public.organizations,
  status jobs_status not null default 'pending',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  completed_at timestamptz,
  tasks_count int not null default 0,
  tasks_completed_count int not null default 0,
  tasks_succeeded_count int not null default 0,

  unique (organization_id, id)
);

create table notifications (
  id bigint generated always as identity primary key,
  organization_id bigint not null references public.organizations on delete cascade,
  body text not null,
  link text,
  entity_id text not null,
  entity_type text not null,
  read bool not null default false,
  created_at timestamptz not null default now()
);

create table plans (
  name text not null,
  price_id text not null,
  max_documents bigint not null,
  max_messages bigint not null,
  max_chatbots bigint not null,
  primary key (price_id)
);

alter table chatbots enable row level security;
alter table documents enable row level security;
alter table conversations enable row level security;
alter table messages enable row level security;
alter table jobs enable row level security;
alter table notifications enable row level security;
alter table plans enable row level security;

alter publication supabase_realtime add table notifications;

create function match_documents (
  query_embedding vector(1536),
  match_count int DEFAULT null,
  filter jsonb DEFAULT '{}'
) returns table (
  id uuid,
  content text,
  metadata jsonb,
  similarity float
)
language plpgsql
as $$
#variable_conflict use_column
begin
  return query
  select
    id,
    content,
    metadata,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  where metadata @> filter
  order by documents.embedding <=> query_embedding
  limit match_count;
end;
$$;

create index on documents using ivfflat (embedding vector_cosine_ops)
with (lists = 100);

create or replace function can_create_chatbot(org_id bigint)
returns bool as $$
declare
    chatbot_count bigint;
    stripe_price_id text;
    quota bigint;
begin
    select count(*) into chatbot_count from chatbots where org_id = organization_id;

    select price_id from get_active_subscription(org_id) into stripe_price_id;

    -- If no subscription is found, then the user is on the free plan
    if stripe_price_id is null then
        return chatbot_count < 1;
    end if;

    select max_chatbots into quota from plans where plans.price_id = stripe_price_id;

    return chatbot_count < quota;
end; $$
language plpgsql;

create or replace function get_active_subscription(org_id bigint)
returns table (
  period_starts_at timestamptz,
  period_ends_at timestamptz,
  price_id text,
  "interval" text
) as $$
begin
    return query select subscriptions.period_starts_at, subscriptions.period_ends_at, subscriptions.price_id, subscriptions."interval" from public.subscriptions
    join organizations_subscriptions on subscriptions.id = organizations_subscriptions.subscription_id
    where organizations_subscriptions.organization_id = org_id;
end;
$$ language plpgsql;

create or replace function can_index_documents(org_id bigint, requested_documents bigint)
returns bool as $$
declare
    documents_quota bigint;
    total_documents bigint;
    stripe_price_id text;
begin
    select count(*) from documents
    join chatbots on chatbots.organization_id = org_id
    where chatbots.organization_id = org_id into total_documents;

    select price_id from get_active_subscription(org_id) into stripe_price_id;
    select max_documents from plans where price_id = stripe_price_id into documents_quota;

    -- If no subscription is found, then the user is on the free plan
    -- and the quota is 50 documents
    if stripe_price_id is null then
        return requested_documents + total_documents <= 50;
    end if;

    return documents_quota >= requested_documents + total_documents;
end; $$
language plpgsql;

create or replace function can_respond_to_message(chatbot uuid)
returns bool as $$
declare
    period_start timestamptz;
    period_end timestamptz;
    stripe_price_id text;
    subscription_interval text;
    messages_sent bigint;
    max_messages_quota bigint;
    org_id bigint;
begin
    select organization_id into org_id from chatbots where chatbots.id = chatbot;

    -- select the subscription period
    select period_starts_at, period_ends_at, price_id, interval
    into period_start, period_end, stripe_price_id, subscription_interval
    from get_active_subscription(org_id);

    -- If no subscription is found, then the user is on the free plan
    -- and the quota is 200 messages per month
    if stripe_price_id is null then
        select count (*) from messages
        where chatbot = messages.chatbot_id
        and messages.type = 'ai'
        and created_at >= date_trunc('month', current_date - interval '1 month')
        and created_at < date_trunc('month', current_date)
        into messages_sent;

        return messages_sent < 200;
    end if;

    -- select the max number of messages allowed in the current period
    select messages from plans where plans.price_id = stripe_price_id into max_messages_quota;

    -- select the number of messages sent in the current period
    select count (*) from messages
    where chatbot = messages.chatbot_id
    and messages.type = 'ai'
    and now() between period_start
    and period_end
    into messages_sent;

    -- If the subscription is yearly, then we need to divide the quota by 12
    if subscription_interval = 'year' then
      max_messages_quota := max_messages_quota / 12;
    end if;

    return max_messages_quota > messages_sent;
end; $$
language plpgsql;

create policy "Users can read Chatbots in their Organization"
  on chatbots
  for select
  to authenticated
  using (
    current_user_is_member_of_organization(organization_id)
  );

create policy "Users can insert Chatbots in their Organization if they have enough quota"
  on chatbots
  for insert
  to authenticated
  with check (
    current_user_is_member_of_organization(organization_id) and can_create_chatbot(organization_id)
);

create policy "Users can update Chatbots in their Organization"
  on chatbots
  for update
  to authenticated
  using (
    current_user_is_member_of_organization(organization_id)
  ) with check (
    current_user_is_member_of_organization(organization_id)
  );

create policy "Users can delete Chatbots in their Organization"
  on chatbots
  for delete
  to authenticated
  using (
    current_user_is_member_of_organization(organization_id)
  );

create policy "Users can select jobs in their Organization"
  on jobs
  for select
  to authenticated
  using (
    current_user_is_member_of_organization(organization_id)
  );

create policy "Users can select documents in their Organization"
  on documents
  for select
  to authenticated
  using (
    current_user_is_member_of_organization((metadata ->> 'organization_id')::int)
  );

create policy "Users can update documents in their Organization"
  on documents
  for update
  to authenticated
  using (
    current_user_is_member_of_organization((metadata ->> 'organization_id')::int)
  ) with check (
    current_user_is_member_of_organization((metadata ->> 'organization_id')::int)
  );

create policy "Users can delete documents in their Organization"
  on documents
  for delete
  to authenticated
  using (
    current_user_is_member_of_organization((metadata ->> 'organization_id')::int)
  );

create policy "Users can read plans"
  on plans
  for select
  to authenticated
    using (
        true
    );